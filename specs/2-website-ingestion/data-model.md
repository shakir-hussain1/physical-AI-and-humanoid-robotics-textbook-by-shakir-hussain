# Data Model: Website URL Ingestion & Vector Storage

## Version
**Model Version:** 1.0.0
**Created:** 2025-12-25
**Last Updated:** 2025-12-25

## Entity Definitions

### 1. IngestURL
**Purpose:** Represents a single URL to be ingested and tracked through the pipeline.

**Fields:**
```
id: UUID (primary key)
url: String (required, validated URL format)
title: String (optional, extracted from page <title> tag)
status: Enum["pending", "processing", "success", "failed"] (required)
error_message: String (optional, populated on failure)
created_at: DateTime (required, ISO 8601)
started_at: DateTime (optional, timestamp of first fetch attempt)
completed_at: DateTime (optional, timestamp of completion)
chunk_count: Integer (optional, number of chunks extracted)
embedding_count: Integer (optional, number of embeddings stored)
retry_count: Integer (default 0, tracks API retry attempts)
```

**Validation Rules:**
- URL must be fully qualified (http:// or https://)
- URL must be reachable (DNS resolvable) before processing
- URL cannot be empty or null
- Status must transition: pending → processing → (success|failed)
- Completed_at must be >= started_at if both present

**State Transitions:**
```
pending → processing (on fetch attempt)
processing → success (all chunks embedded and stored)
processing → failed (after 3 retry attempts)
failed → pending (on manual retry)
```

---

### 2. TextChunk
**Purpose:** Represents a semantic chunk of text extracted from a URL, ready for embedding.

**Fields:**
```
id: UUID (primary key)
ingest_url_id: UUID (foreign key to IngestURL)
chunk_index: Integer (0-based order within page, required)
text_content: String (required, max 4096 chars, actual chunk text)
char_start: Integer (required, starting character position in original text)
char_end: Integer (required, ending character position in original text)
token_count: Integer (required, token count for this chunk)
embedding_id: String (optional, populated after Qdrant storage)
embedding_status: Enum["pending", "embedded", "failed"] (required)
created_at: DateTime (required, ISO 8601)
metadata: JSON (optional, contains page_title, section, language)
```

**Validation Rules:**
- chunk_index must be >= 0 and contiguous (no gaps)
- text_content cannot be empty
- char_start < char_end
- token_count must match actual tiktoken count of text_content
- token_count must be <= 1024 (max chunk size)
- embedding_id format: "vec_{uuid}_{url_hash}_{chunk_index}" (generated by system)

**Relationships:**
- One IngestURL → Many TextChunks (1:N)
- Foreign key constraint on ingest_url_id

---

### 3. Embedding
**Purpose:** Represents the vector embedding generated for a text chunk.

**Fields:**
```
id: UUID (primary key)
chunk_id: UUID (foreign key to TextChunk)
qdrant_vector_id: String (required, ID assigned by Qdrant)
model_name: String (required, e.g., "embed-english-v3.0")
vector_dimension: Integer (required, typically 1024)
generated_at: DateTime (required, ISO 8601)
stored_at: DateTime (optional, timestamp of Qdrant storage)
retrieval_test_passed: Boolean (default false, set after verification)
error_message: String (optional, populated on storage failure)
```

**Validation Rules:**
- qdrant_vector_id must be unique across all embeddings
- vector_dimension must match Cohere model output (1024)
- model_name must be documented in Cohere API compatibility matrix
- generated_at < stored_at if both present
- retrieval_test_passed can only be true if stored_at is populated

**Relationships:**
- One TextChunk → One Embedding (1:1)
- Foreign key constraint on chunk_id

---

### 4. QdrantCollection
**Purpose:** Represents a Qdrant collection managing vectors for a specific ingestion batch or target.

**Fields:**
```
id: UUID (primary key)
name: String (required, collection identifier, unique)
vector_dimension: Integer (required, typically 1024)
distance_metric: Enum["cosine", "euclidean"] (default "cosine")
vector_count: Integer (required, current count of vectors in collection)
max_vectors: Integer (required, quota limit for Free Tier)
created_at: DateTime (required, ISO 8601)
last_updated_at: DateTime (required)
description: String (optional)
```

**Validation Rules:**
- name must match pattern: `[a-z0-9_-]{3,32}`
- vector_count <= max_vectors (quota constraint)
- vector_dimension must match Cohere output
- distance_metric must be supported by Qdrant

**Relationships:**
- One QdrantCollection → Many Embeddings (1:N, implicit via qdrant_vector_id)

---

### 5. IngestionSession
**Purpose:** Represents a single run of the ingestion pipeline (batch operation).

**Fields:**
```
id: UUID (primary key)
session_name: String (required, human-readable identifier)
collection_id: UUID (foreign key to QdrantCollection)
total_urls: Integer (required, count of input URLs)
urls_processed: Integer (required, count of attempted URLs)
urls_succeeded: Integer (required, count of successful ingestions)
urls_failed: Integer (required, count of failed ingestions)
total_chunks_created: Integer (required)
total_chunks_embedded: Integer (required)
total_vectors_stored: Integer (required)
started_at: DateTime (required)
completed_at: DateTime (optional, null if in progress)
status: Enum["running", "completed", "failed"] (required)
error_summary: String (optional, aggregated error details)
```

**Validation Rules:**
- urls_processed = urls_succeeded + urls_failed
- All count fields must be >= 0
- started_at must be <= completed_at if both present
- status = "running" only if completed_at is null

**Relationships:**
- One QdrantCollection → Many IngestionSessions (1:N)
- One IngestionSession → Many IngestURLs (1:N, implicit)

---

### 6. ChunkMetadata (Embedded in TextChunk.metadata JSON)
**Purpose:** Structured metadata associated with a chunk for context and traceability.

**Fields:**
```json
{
  "page_title": "String (extracted from <title> or heading)",
  "section_heading": "String (nearest section header containing chunk)",
  "source_url": "String (canonical URL)",
  "is_code_block": "Boolean (true if chunk is from code block)",
  "language": "String (ISO 639-1, e.g., 'en')",
  "extraction_method": "Enum['beautifulsoup', 'markdown', 'fallback']",
  "chunk_sequence": "Integer (position in extraction order)"
}
```

**Validation Rules:**
- page_title cannot be empty
- source_url must be valid and match parent IngestURL.url
- language must be ISO 639-1 compliant

---

## Key Relationships Diagram

```
IngestURL (1) ──── (N) TextChunk
   │
   ├─ id: UUID
   ├─ url: String
   ├─ status: Enum
   └─ created_at: DateTime

TextChunk (1) ──── (1) Embedding
   │
   ├─ id: UUID
   ├─ chunk_index: Integer
   ├─ token_count: Integer
   └─ embedding_status: Enum

Embedding
   │
   ├─ id: UUID
   ├─ qdrant_vector_id: String (reference to Qdrant)
   └─ retrieval_test_passed: Boolean

QdrantCollection (1) ──── (N) Embeddings (implicit)
   │
   ├─ name: String
   ├─ vector_count: Integer
   └─ max_vectors: Integer

IngestionSession (1) ──── (N) IngestURLs (implicit)
   │
   ├─ id: UUID
   ├─ collection_id: UUID (FK)
   ├─ status: Enum
   └─ completed_at: DateTime
```

---

## State Machines

### IngestURL Status Flow
```
[pending] → [processing] → [success]
    ↓           ↓              ↑
    └───────[failed] ←────────┘
             (max 3 retries)
```

### TextChunk Embedding Status Flow
```
[pending] → [embedded] → [verified in Qdrant]
    ↓
[failed] → [retry with exponential backoff]
```

---

## Data Constraints and Rules

### Quota Management (Free Tier)
- Max vectors per collection: 1,000,000 (Qdrant Free Tier limit)
- Current count tracked in QdrantCollection.vector_count
- Must validate before insertion: `vector_count + new_chunks <= max_vectors`

### Semantic Chunking Constraints
- Max tokens per chunk: 1024
- Min tokens per chunk: 50 (to avoid micro-chunks)
- Overlap strategy: 10% overlap between consecutive chunks for context

### Error Tracking
- All failures logged in IngestURL.error_message with timestamps
- Retry attempts tracked in IngestURL.retry_count (max 3)
- Exponential backoff: 1s, 2s, 4s for retries

---

## Validation Workflows

### On URL Ingestion
1. Validate URL format (http/https)
2. Create IngestURL record with status="pending"
3. Attempt DNS resolution
4. On success: set status="processing", start_time=now()
5. On failure: set status="failed", error_message="DNS failed", return

### On Chunk Creation
1. Extract text from HTML
2. Split into semantic chunks preserving sentence boundaries
3. For each chunk:
   - Count tokens using tiktoken
   - Validate token_count <= 1024
   - Create TextChunk record with embedding_status="pending"
   - Store metadata (page_title, section, language)

### On Embedding Generation
1. Batch chunks (max 100 per Cohere API call)
2. Call Cohere API with retries (max 3)
3. For each embedding:
   - Assign qdrant_vector_id
   - Create Embedding record
   - Set embedding_status="embedded"

### On Vector Storage
1. Check quota: vector_count + new_vectors <= max_vectors
2. Batch insert to Qdrant (max 100 vectors per request)
3. On success: set stored_at=now(), retrieval_test_passed=false
4. Trigger verification query (retrieve by qdrant_vector_id)
5. On retrieval success: set retrieval_test_passed=true

---

## Index Strategy (for future database implementation)

```sql
-- IngestURL indexes
CREATE INDEX idx_ingest_url_status ON ingest_urls(status);
CREATE INDEX idx_ingest_url_created ON ingest_urls(created_at DESC);
CREATE UNIQUE INDEX idx_ingest_url_unique ON ingest_urls(url);

-- TextChunk indexes
CREATE INDEX idx_text_chunk_url_id ON text_chunks(ingest_url_id);
CREATE INDEX idx_text_chunk_status ON text_chunks(embedding_status);
CREATE UNIQUE INDEX idx_text_chunk_embedding ON text_chunks(chunk_id, embedding_id);

-- Embedding indexes
CREATE INDEX idx_embedding_qdrant ON embeddings(qdrant_vector_id);
CREATE INDEX idx_embedding_verified ON embeddings(retrieval_test_passed);

-- IngestionSession indexes
CREATE INDEX idx_session_collection ON ingestion_sessions(collection_id);
CREATE INDEX idx_session_status ON ingestion_sessions(status);
CREATE INDEX idx_session_created ON ingestion_sessions(started_at DESC);

-- QdrantCollection indexes
CREATE UNIQUE INDEX idx_collection_name ON qdrant_collections(name);
```

---

*Data model ensures traceability from URL → chunks → embeddings → Qdrant vectors with full audit trail and recovery capabilities.*
